---
title: "Examining Predictive Pricing Indicators for Cryptocurrency Assets"
author: "Tiffany Valdecantos, Terrill Toe, Adetayo Adegoke"
date: "`r format(Sys.Date())`"
csl: vancouver.csl
biblio-style: vancouver
font-size: 11pt
link-citations: true
output: 
  pdf_document:
    toc: FALSE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE, warning=FALSE}
suppressMessages(library(corrplot))
suppressMessages(library(reshape2))
suppressMessages(library(readr))
suppressMessages(library(caret))
suppressMessages(library(UsingR))
suppressMessages(library(quantmod))
suppressMessages(library(ggplot2))
suppressMessages(library(dplyr))
suppressMessages(library(tseries))
suppressMessages(library(gridExtra))
suppressMessages(library(GGally))
suppressMessages(library(corrplot))
suppressMessages(library(pROC))
suppressMessages(library(MLmetrics))
suppressMessages(library(xgboost))
```

# Research Question and Motivation

According to the U.S. government's Internal Revenue Service (IRS), a virtual currency is a digital representation of value, other than a representation of the U.S. dollar or a foreign currency ("real currency"), that functions as a unit of account, a store of value, and a medium of exchange. The IRS defines cryptocurrencies as a virtual currency that uses cryptography to secure digitally recorded transactions on a distributed ledger, such as a blockchain [1].

Cryptocurrencies are mainstream assets electronically traded by many investors globally, similar to stocks and other equity types. There are many different cryptocurrencies, with several more being introduced to the public every few months for the opportunity to make transactions based on these assets. There is value to examining factors that drive cryptocurrency asset prices since the market size of these currencies is currently over 1 trillion USD in traditional fiat USD and over 32 trillion USD by 2027 [2]. 

Cryptocurrencies significantly influence the global economy because of their growing market size. Researchers examining cryptocurrency pricing predictors can inform government, business, and retail investors in making more profitable trading strategies.

This research paper examines the following question as it pertains to cryptocurrencies:

Can the technical analysis method of analyzing moving averages in Bitcoin prices be effective in predicting future upward price movement?

# Hypothesis

We explore the method of analyzing moving averages used by technical analysts in the capital markets industry to make recommendations for future stock price movements. In doing this, technical analysts search for momentum in price movement caused by the disposition effect, which Bodie defined as “the tendency of investors to hold on to losing investments” (Bodie 384) [3]. To take advantage of this pattern, the investor must sell their holdings once the signal of the momentum of falling prices is determined. Prices would then continue falling until they bottom out and head back up again. At this point, the investor will watch for the signal of the rising momentum of stock prices. Once this signal is determined, that will be the investor’s chance to buy the stock and ride the prices up. Through this strategy, the investor can cut losses when prices are falling and buy stocks cheaper when prices are increasing further, which will result in profits for the investor if all goes according to plan. This paper will only focus on buy strategies associated with upward price movement.

We hypothesize that investors can use a similar approach of analyzing moving averages to predict future movements in Bitcoin prices. Cryptocurrencies are emerging asset classes that researchers have not extensively studied. As such, unseen opportunities may exist. We suspect that the cryptocurrency market has a larger share of retail investors versus institutional investors relative to the traditional stock market. Retail investors do not have the same sophisticated tools that institutional investors have access to, so they may be more predisposed to the disposition effect. This may mean that there are more opportunities to execute successful trading strategies.

# Data Exploration and Methodology

We collected data for this experiment from the following source:

(1) Cryptocurrency Historical Prices [4]

The following features were evaluated for this analysis:

1.	Bit_returns - the simple daily returns using the closing price at time t and t-1
2.	Bit_log_returns - the daily log returns utilizing the closing price at time t and t-1
3.	Bit_days_range - the range in price movements for the given day defined as the highest price - the lowest price of that day
4.	Bit_log_wtd_ret - the week to date returns using the closing price at time t and t-7
5.	Bit_log_biwtd_ret - the bi-weekly to date returns using the closing price at time t and t-14
6.	Bit_log_mtd_ret - the month to date returns using the closing price at time t and t-30
7.	ema_log_ret_7 - the exponential moving average of the week to date returns defined as the weighted average using values in the range of time t and t-7
8.	ema_log_ret_14 - the exponential moving average of the bi-weekly to date returns defined as the weighted average using values in the range of time t and t-14
9.	ema_log_ret_30 - the exponential moving average of the month to date returns defined as the weighted average using values in the field of time t and t-30
10.	ema_log_biret_7 - the exponential moving average using bi-weekly returns between time t and t-7
11.	ema_log_biret_14 - the exponential moving average using bi-weekly returns between time t and t-14
12.	ema_log_biret_30 - the exponential moving average using bi-weekly returns between time t and t-30
13.	moving_avg_10 - the 10-day simple moving average of the closing price
14.	moving_avg_20 - the 20-day simple moving average of the closing price
15.	moving_avg_50 - the 50-day simple moving average of the closing price
16.	moving_avg_50_diff - the difference between the 50-day moving average at t and t-1
17.	moving_avg_50_diff_7 - the difference between the 50-day moving average at t and t-7
18.	Bit_rsi_3 - Momentum indicator using 30 days of prior prices at time t
19.	Bit_rsi_60 - Momentum indicator using 60 days of prior prices at time t
20.	Bit_rsi_90 - Momentum indicator using 90 days of prior prices at time t

Different windows of simple moving averages and exponential moving averages were analyzed. Exponential moving averages are more sensitive to more recent data so they may prove to be better predictors for Bitcoin price movements. (Citation here?) The RSI or Relative Strength Index is another technical analysis indicator used to to determine momentum in price movements. The RSI has values between 0 to 100 with lower values indicating that the stock is oversold and higher values indicating the stock is overbought. (Citation here?)

```{r,eval=TRUE, include=FALSE}

# Get data for Bitcoin (btc)
btc_data <- read.csv("coin_Bitcoin.csv")
str(btc_data)

# Convert the Date column to Date format
btc_data$Date <- as.Date(btc_data$Date, format = "%Y-%m-%d") 

# Transform the Volume and Marketcap columns to scale the data
btc_data$Marketcap <- btc_data$Marketcap / 100000000 
btc_data$Volume <- btc_data$Volume / 100000000

# Sort the data by date in descending order
btc_data <- btc_data[order(btc_data$Date),]

#Check for any null values in the data set
btc_data %>% summarise(across(everything(), ~ sum(is.na(.))))

# Get the daily log returns
btc_data$Bit_log_returns <- c(NA, diff(log(btc_data$Close), lag=1))
btc_data$Bit_log_returns <- round(btc_data$Bit_log_returns, 5)

# Get the daily returns
n <- nrow(btc_data)
prices <- btc_data$Close
returns<- ((prices[2:n] - prices[1:(n-1)])/prices[1:(n-1)])
btc_data$Bit_returns <- c(NA, returns)
btc_data$Bit_returns <- round(btc_data$Bit_returns, 5)

# Get the daily range
btc_data$Bit_days_range <- btc_data$High - btc_data$Low

# Get the week(7 days) to date returns
btc_data$Bit_log_wtd_ret <- c(rep(NA,7), diff(log(btc_data$Close), lag=7))

# Get the week(7 days) to date returns - the past 7 days leading up to the 
# current records time period
btc_data$Bit_log_biwtd_ret <- c(rep(NA,14), diff(log(btc_data$Close), lag=14))

# Get the Bi-weekly(14 days) to date returns
btc_data$Bit_log_mtd_ret <- c(rep(NA,30), diff(log(btc_data$Close), lag=30))

# Get the 7 day exponential moving average of daily returns
btc_data$ema_log_ret_7 <- EMA(btc_data$Bit_log_returns, 7)

# Get the 14 day exponential moving average of daily returns
btc_data$ema_log_ret_14 <- EMA(btc_data$Bit_log_returns, 14)

# Get the 30 day exponential moving average of daily returns
btc_data$ema_log_ret_30 <- EMA(btc_data$Bit_log_returns, 30)

# Create variables for moving averages
btc_data <- mutate(btc_data, moving_avg_10 = 
                     rollmean(Close, 10, fill = 0, align = "right"))
btc_data <- mutate(btc_data, moving_avg_20 = 
                     rollmean(Close, 20, fill = 0, align = "right"))
btc_data <- mutate(btc_data, moving_avg_50 = 
                     rollmean(Close, 50, fill = 0, align = "right"))

# Get the difference between the moving averages
btc_data$moving_avg_50_diff <- c(rep(NA, 2), diff(btc_data$moving_avg_50, 
                                                  lag = 1, differences = 2))
btc_data$moving_avg_50_diff_7 <- c(rep(NA, 14), diff(btc_data$moving_avg_50, 
                                                     lag = 7, differences = 2))

# Get the RSI indicator, for a monthly period, 60 day period and a 90 day period
btc_data$Bit_rsi_3 <- RSI(btc_data$Close, n=30, maType = "EMA") / 100
btc_data$Bit_rsi_60 <- RSI(btc_data$Close, n=60, maType = "EMA") / 100
btc_data$Bit_rsi_90 <- RSI(btc_data$Close, n=90, maType = "EMA") / 100
summary(btc_data)
```
Different windows of simple moving averages and exponential moving averages were analyzed. Exponential moving averages are more sensitive to more recent data [5], so they may prove to be better predictors for Bitcoin price movements. The RSI or Relative Strength Index is another technical analysis indicator used to determine momentum in price movements. The RSI has values between 0 to 100, with lower values indicating that the stock is oversold and higher values indicating the stock is overbought [6].

There are specific properties with time-series data that require extra consideration. Patterns observed in the data, such as trends and seasonality, may result in temporal dependencies between data points. Trends may lead to means that change over time and seasonality may result in variances that change over time. Therefore, the usual regression model assumption of errors being independent normal random variables with a mean of zero and constant variance will not hold.

We run the Augmented Dickey-Fuller (ADF) [7] test on our continuous variables to check for stationary properties. A stationary time series is one whose properties do not depend on the time at which the series is observed and will therefore have more stable means and variances [8].


```{r, eval=TRUE, include=FALSE}
print("################## Testing for the log Returns ##################")
adf.test(btc_data$Bit_log_returns[2:n])

print("################## Testing for the Simple Returns ##################")
adf.test(btc_data$Bit_returns[2:n])

print("################## Testing for the Volume ##################")
adf.test(btc_data$Volume)

print("################## Testing for the Day's Range ##################")
adf.test(btc_data$Bit_days_range)

print("################## Testing for the WTD Returns ##################")
adf.test(btc_data$Bit_log_wtd_ret[8:n])

print("################## Testing for the Bi -WTD Returns ##################")
adf.test(btc_data$Bit_log_biwtd_ret[15:n])

print("################## Testing for the MTD Returns ##################")
adf.test(btc_data$Bit_log_mtd_ret[31:n])

print("################## Testing for the 7 day EMA Daily Returns ##################")
adf.test(btc_data$ema_log_ret_7[8:n])

print("################## Testing for the 14 day EMA Daily Returns ##################")
adf.test(btc_data$ema_log_ret_14[15:n])

print("################## Testing for the 30 day EMA Daily Returns ##################")
adf.test(btc_data$ema_log_ret_30[31:n])

print("################## Testing for 30 day RSI ##################")
adf.test(btc_data$Bit_rsi_3[31:n])

print("################## Testing for 60 day RSI ##################")
adf.test(btc_data$Bit_rsi_60[61:n])

print("################## Testing for 90 day RSI ##################")
adf.test(btc_data$Bit_rsi_90[91:n])

print("################## Testing for 10 day moving average ##################")
adf.test(btc_data$moving_avg_10[11:n])

print("################## Testing for 20 day moving average ##################")
adf.test(btc_data$moving_avg_20[21:n])

print("################## Testing for 50 day moving average ##################")
adf.test(btc_data$moving_avg_50[21:n])

print("################## Testing for the 1 Day Difference between 50 day moving average ##################")
adf.test(btc_data$moving_avg_50_diff[100:n])

print("################## Testing for the 7 Day Difference between 50 day moving average ##################")
adf.test(btc_data$moving_avg_50_diff_7[110:n])
```
```{r,eval=TRUE, warning=FALSE}

print("################## Testing for the Close ##################")
adf.test(btc_data$Close)

print("################## Testing for the Marketcap ##################")
adf.test(btc_data$Marketcap)

print("################## Testing for 20 day moving average ##################")
adf.test(btc_data$moving_avg_20[21:n])

print("################## Testing for 10 day moving average ##################")
adf.test(btc_data$moving_avg_10[11:n])

```
The ADF test shows that the 10-day moving average, 20-day moving average, the Closing Price, and Market Cap have unit roots were non-stationary. We account for the non-stationary features in statistical models for time series data sets by creating features based on calculating the differences between consecutive observations in the data [9]. This is the motivation behind creating the variables moving_avg_50_diff and moving_avg_50_diff_7.

Now that we understand what is stationary and non-stationary and have accounted for non-stationary features let's discuss the target variables. Observe the graphs below:

```{r,eval=TRUE, include=FALSE, warning=FALSE}

time_cols <- c("Date", "Bit_log_wtd_ret", "Bit_log_biwtd_ret",
               "Bit_log_mtd_ret")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + ggtitle("Log WTD, BI-WTD, and MTD Returns")

time_cols <- c("Date", "ema_log_ret_7", "ema_log_ret_14","ema_log_ret_30")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line2<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + geom_hline(aes(yintercept = 0, colour = "Black")) + ggtitle("EMA 7, 14, and 30 days of Daily Log Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
wtd_dens <-  ggplot(btc_data, aes(x=Bit_log_wtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("WTD Returns")

wtd_qq <- ggplot(btc_data, aes(sample = Bit_log_wtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("WTD Returns")

wtd_box <- ggplot(btc_data, aes(y = Bit_log_wtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("WTD Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
biwtd_dens <-  ggplot(btc_data, aes(x=Bit_log_biwtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("Bi-WTD Returns")

biwtd_qq <- ggplot(btc_data, aes(sample = Bit_log_biwtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("Bi-WTD Returns")

biwtd_box <- ggplot(btc_data, aes(y = Bit_log_biwtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("Bi-WTD Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
mtd_dens <-  ggplot(btc_data, aes(x=Bit_log_mtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("MTD Returns")

mtd_qq <- ggplot(btc_data, aes(sample = Bit_log_mtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("MTD Returns")

mtd_box <- ggplot(btc_data, aes(y = Bit_log_mtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("MTD Returns")

# Plot the Moving average difference returns as a density plot, box plot, and qqplot
ma_diff_dens <-  ggplot(btc_data, aes(x=moving_avg_50_diff)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("50 Day MA 1 day differnence")

ma_diff_qq <- ggplot(btc_data, aes(sample = moving_avg_50_diff)) + stat_qq() + stat_qq_line() + ggtitle("50 Day MA 1 day differnence")

ma_diff_box <- ggplot(btc_data, aes(y = moving_avg_50_diff)) + geom_boxplot(width = 0.5) + ggtitle("50 Day MA 1 day differnence")

# Plot the Moving Average as a density plot, box plot, and qqplot
ma7_diff_dens <-  ggplot(btc_data, aes(x=moving_avg_50_diff_7)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("50 Day MA 7 days differnence")

ma7_diff_qq <- ggplot(btc_data, aes(sample = moving_avg_50_diff_7)) + stat_qq() + stat_qq_line() + ggtitle("50 Day MA 7 days differnence")

ma7_diff_box <- ggplot(btc_data, aes(y = moving_avg_50_diff_7)) + geom_boxplot(width = 0.5) + ggtitle("50 Day MA 7 days differnence")

# Create time series chart of the moving averages
time_cols <- c("Date", "moving_avg_50_diff_7", "moving_avg_50_diff")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line_ma<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + ggtitle("Moving Averages difference from Jan 2014 - Jan 2015")

grid.arrange(time_line, time_line2, ncol = 1, nrow = 2)
grid.arrange(wtd_dens, wtd_qq, wtd_box, biwtd_dens, biwtd_qq, biwtd_box, mtd_dens, mtd_qq, mtd_box, ncol = 3, nrow = 3)
grid.arrange(ma_diff_dens, ma_diff_qq, ma_diff_box, ma7_diff_dens, ma7_diff_qq, ma7_diff_box, ncol = 3, nrow = 2)
grid.arrange(time_line_ma, ncol = 1, nrow = 1)

#Let's create a another exponential moving average set of features, this time using a bi-weekly cadence.

#Get the 7 day exponential moving average of daily returns
btc_data$ema_log_biret_7 <- EMA(btc_data$Bit_log_biwtd_ret, 7)
#Get the 14 day exponential moving average of daily returns
btc_data$ema_log_biret_14 <- EMA(btc_data$Bit_log_biwtd_ret, 14)
#Get the 30 day exponential moving average of daily returns
btc_data$ema_log_biret_30 <- EMA(btc_data$Bit_log_biwtd_ret, 30)

time_cols <- c("Date", "ema_log_biret_7", "ema_log_biret_14","ema_log_biret_30")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line3<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + geom_hline(aes(yintercept = 0, colour = "Black")) + ggtitle("EMA 7, 14, and 30 days of BI Weekly to date Log Returns")

time_cols <- c("Date", "Close")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
time_line6<- ggplot(btc_time,
                   aes(x = Date,
                       y = Close,
                       alpha=0.25)) +
              geom_line() + ggtitle("Prices Jan 2014 - Jan 2015")

#plot the 50 day moving average
time_cols <- c("Date", "moving_avg_50")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
time_line50<- ggplot(btc_time,
                   aes(x = Date,
                       y = moving_avg_50,
                       alpha=0.25)) +
              geom_line() + ggtitle("Prices Jan 2014 - Jan 2015")
ma_dens <-  ggplot(btc_data, aes(x=moving_avg_50)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("MTD Returns")
ma_qq <- ggplot(btc_data, aes(sample = moving_avg_50)) + stat_qq() + stat_qq_line() + ggtitle("MTD Returns")
ma_box <- ggplot(btc_data, aes(y = moving_avg_50)) + geom_boxplot(width = 0.5) + ggtitle("MTD Returns")

grid.arrange(time_line2, time_line3, time_line6, time_line50, ncol = 1, nrow = 4)
grid.arrange(ma_dens, ma_qq, ma_box, ncol = 3, nrow = 1)


#Get the EMA for monthly returns, plot it against the ema for Bi wtd and closing prices of Bitcoin

#Get the 7 day exponential moving average of daily returns
btc_data$ema_log_mtdret_7 <- EMA(btc_data$Bit_log_mtd_ret, 7)

#Get the 14 day exponential moving average of daily returns
btc_data$ema_log_mtdret_14 <- EMA(btc_data$Bit_log_mtd_ret, 14)

#Get the 30 day exponential moving average of daily returns
btc_data$ema_log_mtdret_30 <- EMA(btc_data$Bit_log_mtd_ret, 30)

time_cols <- c("Date", "ema_log_mtdret_7", "ema_log_mtdret_14","ema_log_mtdret_30")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line5<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + geom_hline(aes(yintercept = 0, colour = "Black")) + ggtitle("EMA 7, 14, and 30 days of MTD Log Returns")

time_cols <- c("Date", "Close")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

grid.arrange(time_line3, time_line5, time_line6, ncol = 1, nrow = 3)

#Get the graphs of the EMA values that were recently created.

# plot the simple returns as a density plot, box plot, and qqplot
ema_mtd_dens <-  ggplot(btc_data, aes(x=ema_log_mtdret_30)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("EMA 30 MTD Returns")
ema_mtd_qq <- ggplot(btc_data, aes(sample = ema_log_mtdret_30)) + stat_qq() + stat_qq_line() + ggtitle("EMA 30 MTD Returns")
ema_mtd_box <- ggplot(btc_data, aes(y = ema_log_mtdret_30)) + geom_boxplot(width = 0.5) + ggtitle("EMA 30 MTD Returns")

# plot the simple returns as a density plot, box plot, and qqplot
ema_biwtd_dens <-  ggplot(btc_data, aes(x=ema_log_biret_30)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("EMA BI-WTD Returns")
ema_biwtd_qq <- ggplot(btc_data, aes(sample = ema_log_biret_30)) + stat_qq() + stat_qq_line() + ggtitle("EMA 30 BI-WTD Returns")
ema_biwtd_box <- ggplot(btc_data, aes(y = ema_log_biret_30)) + geom_boxplot(width = 0.5) + ggtitle("EMA 30 BI-WTD Returns")

grid.arrange(ema_mtd_dens, ema_mtd_qq, ema_mtd_box, ema_biwtd_dens, ema_biwtd_qq, ema_biwtd_box, ncol = 3, nrow = 2)

#Shift the columns back n days so current features align with the labeled future values
n <- nrow(btc_data) 
btc_data$Bit_log_wtd_ret_lag <- c(btc_data$Bit_log_wtd_ret[8:n], rep(NA,7))
btc_data$Bit_log_biwtd_ret_lag <- c(btc_data$Bit_log_biwtd_ret[15:n], rep(NA,14))
btc_data$Bit_log_mtd_ret_lag <- c(btc_data$Bit_log_mtd_ret[31:n], rep(NA,30))

#Create the indicators on when to buy when to sell and when to hold
btc_data$buy_sell_ind_wtd <- ifelse(btc_data$Bit_log_wtd_ret_lag >=  0.2, 1, ifelse(btc_data$Bit_log_wtd_ret_lag <=  -0.15, -1, 0))
btc_data$buy_sell_ind_biwtd <- ifelse(btc_data$Bit_log_biwtd_ret_lag >=  0.2, 1, ifelse(btc_data$Bit_log_biwtd_ret_lag <=  -0.15, -1, 0))
btc_data$buy_sell_ind_mtd <- ifelse(btc_data$Bit_log_mtd_ret_lag >=  0.2, 1, ifelse(btc_data$Bit_log_mtd_ret_lag <=  -0.15, -1, 0))

# Make the new columns as factor type
btc_data$buy_sell_ind_wtd <- as.factor(btc_data$buy_sell_ind_wtd)
btc_data$buy_sell_ind_biwtd <- as.factor(btc_data$buy_sell_ind_biwtd)
btc_data$buy_sell_ind_mtd <- as.factor(btc_data$buy_sell_ind_mtd)

# remove the rows with null values at the beginning and end of the data frame.
btc <- btc_data[complete.cases(btc_data),]

#Look at the relationships between EMA Values and their expected future returns

day <- ggplot(btc_data, aes(x=Bit_log_mtd_ret, y=Bit_log_wtd_ret_lag, color=buy_sell_ind_wtd)) + 
        geom_point(alpha=0.5, shape=18) + geom_vline(aes(xintercept = 0)) + geom_hline(aes(yintercept = 0))

week <- ggplot(btc_data, aes(x=ema_log_biret_30, y=Bit_log_wtd_ret_lag, color=buy_sell_ind_wtd)) + 
        geom_point(alpha=0.5, shape=18) + geom_vline(aes(xintercept = 0)) + geom_hline(aes(yintercept = 0))

month <- ggplot(btc_data, aes(x=Bit_log_biwtd_ret_lag, y=Bit_log_mtd_ret_lag, color=buy_sell_ind_mtd)) + 
        geom_point(alpha=0.5, shape=18) + geom_vline(aes(xintercept = 0)) + geom_hline(aes(yintercept = 0))

grid.arrange(day, week, month, ncol = 1, nrow = 3)

names(btc_data)
cor_feat <- cor(btc_data[, 5:34])
corrplot(cor_feat, method="color", addCoef.col = 0.5, number.cex = 0.5, tl.cex = 0.5)

```
Now that we have an understanding of what is stationary and non-stationary and we have accounted for non-stationary features, let's discuss the target variables. Observe the below graphs:

```{r, eval=TRUE, warning=FALSE}
# plot the simple returns as a density plot, box plot, and qqplot
wtd_dens <-  ggplot(btc_data, aes(x=Bit_log_wtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("WTD Returns")

wtd_qq <- ggplot(btc_data, aes(sample = Bit_log_wtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("WTD Returns")

wtd_box <- ggplot(btc_data, aes(y = Bit_log_wtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("WTD Returns")

grid.arrange(wtd_dens, wtd_qq, wtd_box, biwtd_dens, biwtd_qq, biwtd_box, mtd_dens, mtd_qq, mtd_box, ncol = 3, nrow = 3)

```
Since the log weighted returns appear closer to normal, we use this variable to label our indicator target variables. Even though there is some variation in the tails, the overall shape is still normal. Our purpose for this analysis is to search for the momentum of Bitcoin upward price movements since investors can create different buy strategies if they can predict these movements. For this purpose, we use the following thresholds to label our momentum indicator target variables. If the log of average returns over the future month period is greater than 20%, it is marked "1" as a potential buy opportunity. Otherwise, the target variable is marked "0" to indicate a window of price movement due to random variation or downward price movement, which is outside the scope of our analysis.

The choice of the 20% threshold is arbitrary so further analysis may be required to determine the optimum threshold. Certain considerations may need to be made in deciding this threshold, such as the level of an investor’s conservativeness and transaction expenses. The price movement needs to be big enough for the investor to pay transaction costs to initiate their strategy, so they do not want to be too sensitive and react to events that end up being immaterial. Our team decided that 20% up is a large enough price movement to warrant action.

The green points in the plot below show the target variables as potential buy opportunities:

```{r, eval=TRUE, warning=FALSE}
#plot the buy points on a chart of prices.
time_cols <- c("Date", "Close", "buy_sell_ind_mtd")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2013-06-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
btc_points <- btc_time[btc_time$buy_sell_ind_mtd == 1, ]
plot(x = btc_time$Date,
    y = btc_time$Close, main = "Buy Indicators between Jun 2013 - Jan 2015 (Green)",
    xlab = "Date", ylab = "Price")
points(x = btc_points$Date, y=btc_points$Close, col="green")
```
Since the form of the question we are trying to answer is categorical - Is this a good time to buy? – we decided to look at classification models instead of regression models. Logistic regression was ruled out due to the assumptions being violated with time-series data as explained above. Additionally, the predictor variables are highly correlated since they are moving averages over overlapping periods and linear models do not perform well with high correlation between predictors. From among the remaining tools available for classification problems, we chose Extreme Gradient Boosting for this analysis.

#### Results and Conclusions

Due to the unique nature of time series data, special consideration was needed to create the training and test data sets. The data points are time-dependent, and we needed to keep the temporal structure of the data, so the usual way of randomly splitting the data into training and test sets would not work. Instead, we kept the older 70% of the data as the training set and left the more recent 30% of the data as test. This way, we retain the order of the data points in both the training and test data sets.

From among the features we examined, only the features below were found to be important in our Extreme Gradient Boosting model:

```{r, eval=TRUE, warning=FALSE, include=FALSE}
#Partition the data into training and testing sets.
train_indx <- round(0.7 * nrow(btc))
btc_train <- btc[1:train_indx,]
test_indx <- train_indx + 1
n_btc <- nrow(btc)
btc_test <- btc[test_indx:n_btc,]

str(btc_train)
rm_cols <- c("SNo", "Name", "Symbol", "High", "Low", "Open", "Close", "Marketcap", "buy_sell_ind_wtd", "buy_sell_ind_biwtd",
             "Bit_log_wtd_ret_lag", "Bit_log_biwtd_ret_lag", "Bit_log_mtd_ret_lag", "buy_sell_ind_mtd", "moving_avg_10",
             "moving_avg_20")
#Predict on when is a good time to buy
btc_train$buy_indicator <- ifelse(btc_train$buy_sell_ind_mtd == 1, 1, 0)
btc_test$buy_indicator <- ifelse(btc_test$buy_sell_ind_mtd == 1, 1, 0)
btc_train <- btc_train[, !(colnames(btc_train) %in% rm_cols)]
btc_test <- btc_test[, !(colnames(btc_test) %in% rm_cols)]

# Convert the date into integers of month day and year, each with its own column to preserve the temporal aspect of the data

btc_train <- btc_train %>%
    dplyr::mutate(., 
                  months = lubridate::month(Date),
                  years = lubridate::year(Date),
                  days = lubridate::day(Date))

btc_test <- btc_test %>%
    dplyr::mutate(., 
                  months = lubridate::month(Date),
                  years = lubridate::year(Date),
                  days = lubridate::day(Date))
#Convert the days column to numeric
btc_test$days <- as.numeric(btc_test$days)
btc_train$days <- as.numeric(btc_train$days)
btc_test$months <- as.numeric(btc_test$months)
btc_train$months <- as.numeric(btc_train$months)
btc_test$year <- as.numeric(btc_test$years)
btc_train$years <- as.numeric(btc_train$years)
```
```{r, eval=TRUE, warning=FALSE, include=FALSE}
#create the matrix values for the xgboost and only inlcude important features
x_train_2 <- btc_train %>%
                    dplyr::select(months, days, years,
                    Bit_log_mtd_ret, ema_log_ret_14, Bit_rsi_90,
                    ema_log_mtdret_30, moving_avg_50_diff_7) %>%
                  as.matrix()

x_test_2 <- btc_test %>% 
                  dplyr::select(months, days, years,
                    Bit_log_mtd_ret, ema_log_ret_14, Bit_rsi_90,
                    ema_log_mtdret_30, moving_avg_50_diff_7) %>%
                as.matrix()

y_train <- as.factor(btc_train$buy_indicator)
y_test <- as.factor(btc_test$buy_indicator)
```
```{r, eval=TRUE, warning=FALSE, include=FALSE}

set.seed(123)
xgb_trcontrol_2 <- caret::trainControl(
   method = "timeslice",
   initialWindow = 700,
   horizon = 200,
   fixedWindow = FALSE, 
   allowParallel = FALSE
)
 
xgb_grid_2 <- base::expand.grid(
   list(
    nrounds = c(100, 200),
    max_depth = c(10, 15, 20), # maximum depth of a tree
    colsample_bytree = seq(0.5), # subsample ratio of columns when construction each tree
    eta = 0.1, # learning rate
    gamma = 0, # minimum loss reduction
    min_child_weight = 1,  # minimum sum of instance weight (hessian) needed ina child
    subsample = 1 # subsample ratio of the training instances
))

```
```{r, eval=TRUE, warning=FALSE, include=FALSE, cache=TRUE}

xgb_model_2 <- suppressMessages(caret::train(
   x_train_2, y_train,
   trControl = xgb_trcontrol_2,
   tuneGrid = xgb_grid_2,
   method = "xgbTree",
   nthread = 1,
   objective = "binary:logistic"
))

```
```{r, eval=TRUE, warning=FALSE}
importance_matrix2 <- xgb.importance(model = xgb_model_2$finalModel)
xgb.plot.importance(importance_matrix = importance_matrix2, main="Variable Importance")
```
Our final model includes only the most essential features to predict momentum in Bitcoin price movement. Below are the results of our final model:

```{r, eval=TRUE, warning=FALSE}
train_predicted_2 <- xgb_model_2 %>% predict(x_train_2)

# Confusion matrix
confMat1_2 <- confusionMatrix(train_predicted_2, as.factor(btc_train$buy_indicator), positive='1')
print("Results on training data:")
confMat1_2

test_predicted_2 <- xgb_model_2 %>% predict(x_test_2)

# Confusion matrix
confMat2_2 <- confusionMatrix(test_predicted_2, as.factor(btc_test$buy_indicator), positive='1')
print("Results on testing data:")
confMat2_2

```
Although we have an accuracy of 100% on the training data, the accuracy dropped down to 66% on the test data, which points to the possibility of over-fitting. The model, therefore, may not be as effective in predicting momentum in Bitcoin price movement when faced with unseen data. Additionally, although the accuracy of 100% was higher than the 79% baseline rate on the training data, this failed to translate over when the model was applied to the test data, with the accuracy of 66% being below the baseline rate of 67%. Sadly, these results do not point to an adequate model, and more analysis will be required.

The ROC curves also indicate possible over-fitting, with the curve on the training data almost touching the upper left corner with an AUC of 100%, while the curve on the test data is closer to the diagonal of the graph with an AUC of 52%:

```{r, eval=TRUE, warning=FALSE, message=FALSE}
#Plot roc curves for training and test data
pred_train <- xgb_model_2 %>% predict(x_train_2, type = 'prob')
r_train = multiclass.roc(as.factor(btc_train$buy_indicator), pred_train[,2], percent = T)[['rocs']][[1]]

pred_test <- xgb_model_2 %>% predict(x_test_2, type = 'prob')
r_test = multiclass.roc(as.factor(btc_test$buy_indicator), pred_test[,2], percent = T)[['rocs']][[1]]

plot.roc(r_test, col = 'red', lwd = 5, main = "ROC Curves: Bitcoin Price Momentum", print.auc = T, auc.polygon = T, max.auc.polygon = T,
         auc.polygon.col = 'lightblue')

plot(r_train, add = T, col = 'blue')
```

# Challenges and Limitations

This analysis examined different windows of moving averages as predictors of future Bitcoin price movement. An inherent limitation of this approach is that a certain period would need to elapse before a moving average over the period can be calculated. Any model built using moving averages as predictors therefore will not react as quickly as other models. Depending on the size of the investment, this flaw could lead to substantial losses for the investor, especially in the highly volatile cryptocurrency markets. However, the conservative nature of this approach could also be seen as an advantage depending on the investor's risk appetite. More conservative investors would not want to react too quickly to random price movements as there are substantial costs to initiate any buy strategy - transaction expenses and tax implications, to name a few.

An additional limitation is the use of daily data for this analysis. Cryptocurrency markets operate 24/7, and data is readily available to the fraction of a second. However, processing data of this magnitude would be no easy task, not to mention the storage and computing power required. Although there are advantages to processing more timely data as it might overcome the limitations of using moving averages as explained above, we are forced to rely on daily data due to the challenges mentioned above.

# Further Discussion and Research

This analysis used the threshold of 20% to label the target variables for Bitcoin price momentum upwards. The threshold needed to be big enough to not incorrectly flag the random noise in price movement as momentum events. The investor would not want to be too reactive to random price movement as each buy transaction requires payment of fees, and there may be tax implications as well. The 20% threshold, therefore, made the most intuitive sense, but further study will be needed to determine the optimum threshold.

We focused on predicting Bitcoin price movement upward but did not examine price movements down as this was deemed outside the scope of our initial research question. Further investigation would need to be done to see if an effective model can be created to predict downward price movements.

Our analysis resulted in an overfit model. It is possible that increasing the minimum loss reduction parameter will lead to a better performing model. Further research is required to determine if this is true.

Additionally, this analysis examined many different windows of moving averages and exponential moving averages for features - 7 days, 14 days, 30 days, etc. - and average log returns over the future month period for the target variable. Different windows of moving averages may be more predictive, but further research is required.

One more interesting topic to discuss is the Efficient Market Hypothesis and the implications this may have for this analysis. According to Bodie, the Efficient Market Hypothesis is "the notion that stocks already reflect all available information" (Bodie 335). If the Efficient Market Hypothesis is accurate, stock prices immediately adjust to any new information made public so that historical trading data - such as what was used in this analysis - cannot be used to predict future price movement to execute successful trading strategies. The Efficient Market Hypothesis refers to traditional stock prices and it is unknown whether it also holds for cryptocurrency. Further research is needed, but if the Efficient Market Hypothesis does hold, it might partially explain the results from this analysis that predictors using moving average were not effective in predicting future Bitcoin price movements.

# References

[1]	“Frequently Asked Questions on Virtual Currency Transactions | Internal Revenue Service.” Irs.gov. U.S. Internal Revenue Service. N.d. Web. 04 May 2022. https://www.irs.gov/individuals/international-taxpayers/frequently-asked-questions-on-virtual-currency-transactions 

[2]	“Global Cryptocurrency Market Report 2022-2027 - Industry to Cross a Staggering $32.4 Trillion by 2027, Exploding with a CAGR of 58.4%.” yahoo.com. yahoo.com Research and Markets. N.d. Web. 04 May 2022. https://finance.yahoo.com/news/global-cryptocurrency-market-report-2022-120800380.html 

[3]	“Investments.” Investments, 11th edition, Bodie, Kane, and Marcus. Vk.com. N.d. Web. 04 May 2022. https://vk.com/doc399904795_482800477?hash=dsrEOFu8Ngw46PuoF8SCx47HjNUti1QlTC96UzdSEWL

[4]	“Cryptocurrency Historical Prices | Kaggle.” Kaggle.com. Kaggle bitcoin dataset. N.d. Web. 04 May 2022. https://www.kaggle.com/datasets/sudalairajkumar/cryptocurrencypricehistory?resource=download 
	
[5]	“Exponential Moving Average (EMA) Definition.” Investopedia.com. Technical Analysis Basic Education. N.d. Web. 04 May 2022. https://www.investopedia.com/terms/e/ema.asp
	
[6]	“Relative Strength Index (RSI) Definition.” Investopedia.com. Technical Analysis Basic Education. N.d. Web. 04 May 2022. https://www.investopedia.com/terms/r/rsi.asp
	
[7]	“Augmented Dickey-Fuller Test in R (With Example).” Statology.org. Statology. N.d. Web. 04 May 2022. https://www.statology.org/dickey-fuller-test-in-r/ 

[8]	“6.4.4.2 Stationarity.” Nist.gov. Engineering Statistics Handbook. N.d. Web. 04 May 2022. https://www.itl.nist.gov/div898/handbook/pmc/section4/pmc442.htm 

[9]	“How to Remove Non-Stationarity in Time Series Forecasting | by Bex T. | Towards Data Science.” Towardsdatascience.com. How to Remove Non-Stationarity in Time Series Forecasting. N.d. Web. 04 May 2022. https://towardsdatascience.com/how-to-remove-non-stationarity-in-time-series-forecasting-563c05c4bfc7 

