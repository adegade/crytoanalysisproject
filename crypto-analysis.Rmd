---
title: "Examining predictive pricing indicators for cryptocurrency assets"
author: "Tiffany Valdecantos, Terrill Toe, Adetayo Adegoke"
date: "`r format(Sys.Date())`"
csl: vancouver.csl
biblio-style: vancouver
bibliography: references.bib
font-size: 11pt
link-citations: true
output: 
  pdf_document:
    toc: FALSE
    citation_package: biblatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE}
# install packages
suppressMessages(library(corrplot))                 # Install reshape2 package
suppressMessages(library("reshape2"))
suppressMessages(library(readr))
suppressMessages(library(caret))
suppressMessages(library(UsingR))
suppressMessages(library(quantmod))
suppressMessages(library(ggplot2))
suppressMessages(library(dplyr))
suppressMessages(library(tseries))
suppressMessages(library(gridExtra))
suppressMessages(library(GGally))
suppressMessages(library(corrplot))
suppressMessages(library(pROC))
suppressMessages(library(MLmetrics))
suppressMessages(library(xgboost))
suppressMessages(library(doParallel))

# Source our R script with functions
source("src/quant_funcs.R")

```

# Research Question and Motivation

According to the U.S. government's Internal Revenue Service (IRS), a virtual currency is a digital representation of value, other than a representation of the U.S. dollar or a foreign currency ("real currency"), that functions as a unit of account, a store of value, and a medium of exchange. The IRS also defines cryptocurrencies as a virtual currency that uses cryptography to secure digitally recorded transactions on a distributed ledger, such as a blockchain @CryptoDefIrs.

Cryptocurrencies are mainstream assets electronically traded by many investors globally, similar to stocks and other equity types. There are many different cryptocurrencies, with several more being introduced to the public every few months for the opportunity to make transactions based on these assets. There is value to examining factors that drive cryptocurrency asset prices since the market size of these currencies is currently over 1 trillion USD in traditional fiat USD and over 32 trillion USD by 2027 @CryptoMarketSizeYahoo.

Cryptocurrencies significantly influence the global economy because of their growing market size. Researchers examining cryptocurrency pricing predictors can inform government, business, and retail investors in making more efficient transactions.

# Hypothesis

This research paper examines the following questions as it pertains to the Bitcoin (BTC) cryptocurrency:

*Can the technical analysis method of looking at the relation of bitcoin prices to a moving average predict future price movements?*

We explore the method of analyzing moving averages used by technical analysts in the capital markets industry to make recommendations for stock price movements. In doing this, technical analysts search for momentum in price movement caused by the disposition effect, which Bodie, Kane, and Marcus defined as “the tendency of investors to hold on to losing investments” @Investments11Edition. To take advantage of this pattern, the investor must sell their holdings once the signal of the momentum of falling prices is determined. Prices would then continue falling until they bottom out and head back up again. At this point, the investor will watch for the signal of the rising momentum of stock prices. Once this signal is determined, that will be the investor’s chance to buy the stock and ride the prices up. Through this strategy, the investor can cut losses when prices are falling and buy stocks cheaper when prices are increasing further, which will result in profits for the investor if all goes according to plan.

We hypothesize that investors can use a similar approach of moving averages to predict future movements in Bitcoin prices. Cryptocurrencies are emerging asset classes that researchers have not extensively studied. As such, unseen opportunities may exist. We suspect that the cryptocurrency market has a larger share of retail investors versus institutional investors relative to the traditional stock market. Retail investors do not have the same sophisticated tools that institutional investors have access to, so they may be more predisposed to the disposition effect.

An investor using the technical analysis approach of moving averages would surmise that when current asset prices move from above to below the moving average line, this is an indicator that future bitcoin prices will head lower. The investor would consider selling their holdings as a consequence of this event. Conversely, if asset prices head from below to above the moving average line, this is a buy signal to an investor.

# Data Source and Engineering

We collected data for this experiment from the following sources:

(1) Cryptocurrency Historical Prices @CryptoPrices

The following features were evaluated for this analysis:

1. Bit_returns - the simple daily returns using the closing price at time t and t-1
2. Bit_log_returns - the daily log returns using the closing price at time t and t-1
3. Bit_days_range - the range in price movements for the given day defined as highest price - the lowest price of that day
4. Bit_log_wtd_ret - the week to date returns using the closing price at time t and t-7
5. Bit_log_biwtd_ret - the bi-weekly to date returns using the closing price at time t and t-14
6. Bit_log_mtd_ret - the month to date returns using the closing price at time t and t-30
7. ema_log_ret_7 - the exponential moving average of the week to date returns defined as the weighted average using values in range of time t and t-7
8. ema_log_ret_14 - the exponential moving average of the bi-weekly to date returns defined as the weighted average using values in range of time t and t-14
9. ema_log_ret_30 - the exponential moving average of the month to date returns defined as the weighted average using values in range of time t and t-30
10. ema_log_biret_7 - the exponential moving average using bi-weekly returns between time t and t-7
11. ema_log_biret_14 - the exponential moving average using bi-weekly returns between time t and t-14
12. ema_log_biret_30 - the exponential moving average using bi-weekly returns between time t and t-30
13. moving_avg_10 - the 10-day simple moving average of the closing price
14. moving_avg_20 - the 20-day simple moving average of the closing price
15. moving_avg_50 - the 50-day simple moving average of the closing price
16. moving_avg_50_diff - the difference between the 50-day moving average at t and t-1
17. moving_avg_50_diff_7 - the difference between the 50-day moving average at t and t-7
18. Bit_rsi_3 - Momentum indicator using 30 days of prior prices at time t
19. Bit_rsi_60 - Momentum indicator using 60 days of prior prices at time t
20. Bit_rsi_90 - Momentum indicator using 90 days of prior prices at time t

Different windows of simple moving averages and exponential moving averages were analyzed. Exponential moving averages are more sensitive to more recent data so they may prove to be better predictors for Bitcoin price movements. The RSI or Relative Strength Index is another technical analysis indicator used to to determine momentum in price movements. The RSI has values between 0 to 100 with lower values indicating that the stock is oversold and higher values indicating the stock is overbought.

```{r,eval=TRUE,warning=FALSE}

# The chart below shows the historical movement in Bitcoin prices compared to 
# the 50-day moving average

# Get data for Bitcoin (btc)
btc_data <- read.csv("coin_Bitcoin.csv")
str(btc_data)

# Convert the Date column to Date format
btc_data$Date <- as.Date(btc_data$Date, format = "%Y-%m-%d") 

# Transform the Volume and Marketcap columns to scale the data
btc_data$Marketcap <- btc_data$Marketcap / 100000000 
btc_data$Volume <- btc_data$Volume / 100000000

# Sort the data by date in descending order
btc_data <- btc_data[order(btc_data$Date),]

#Check for any null values in the data set
btc_data %>% summarise(across(everything(), ~ sum(is.na(.))))

# Get the daily log returns
btc_data$Bit_log_returns <- c(NA, diff(log(btc_data$Close), lag=1))
btc_data$Bit_log_returns <- round(btc_data$Bit_log_returns, 5)

# Get the daily returns
n <- nrow(btc_data)
prices <- btc_data$Close
returns<- ((prices[2:n] - prices[1:(n-1)])/prices[1:(n-1)])
btc_data$Bit_returns <- c(NA, returns)
btc_data$Bit_returns <- round(btc_data$Bit_returns, 5)

# Get the daily range
btc_data$Bit_days_range <- btc_data$High - btc_data$Low

# Get the week(7 days) to date returns
btc_data$Bit_log_wtd_ret <- c(rep(NA,7), diff(log(btc_data$Close), lag=7))

# Get the week(7 days) to date returns - the past 7 days leading up to the 
# current records time period
btc_data$Bit_log_biwtd_ret <- c(rep(NA,14), diff(log(btc_data$Close), lag=14))

# Get the Bi-weekly(14 days) to date returns
btc_data$Bit_log_mtd_ret <- c(rep(NA,30), diff(log(btc_data$Close), lag=30))

# Get the 7 day exponential moving average of daily returns
btc_data$ema_log_ret_7 <- EMA(btc_data$Bit_log_returns, 7)

# Get the 14 day exponential moving average of daily returns
btc_data$ema_log_ret_14 <- EMA(btc_data$Bit_log_returns, 14)

# Get the 30 day exponential moving average of daily returns
btc_data$ema_log_ret_30 <- EMA(btc_data$Bit_log_returns, 30)

# Create variables for moving averages
btc_data <- mutate(btc_data, moving_avg_10 = 
                     rollmean(Close, 10, fill = 0, align = "right"))
btc_data <- mutate(btc_data, moving_avg_20 = 
                     rollmean(Close, 20, fill = 0, align = "right"))
btc_data <- mutate(btc_data, moving_avg_50 = 
                     rollmean(Close, 50, fill = 0, align = "right"))

# Get the difference between the moving averages
btc_data$moving_avg_50_diff <- c(rep(NA, 2), diff(btc_data$moving_avg_50, 
                                                  lag = 1, differences = 2))
btc_data$moving_avg_50_diff_7 <- c(rep(NA, 14), diff(btc_data$moving_avg_50, 
                                                     lag = 7, differences = 2))

# Get the RSI indicator, for a monthly period, 60 day period and a 90 day period
btc_data$Bit_rsi_3 <- RSI(btc_data$Close, n=30, maType = "EMA") / 100
btc_data$Bit_rsi_60 <- RSI(btc_data$Close, n=60, maType = "EMA") / 100
btc_data$Bit_rsi_90 <- RSI(btc_data$Close, n=90, maType = "EMA") / 100
summary(btc_data)
```

Because we are dealing with time series data, we will run the Augmented Dickey Fuller (ADF) test on our continuous variables to test for stationarity.A stationary time series is one whose properties do not depend on the time at which the series is observed.@Stationarity

```{r,eval=TRUE,warning=FALSE}

print("################## Testing for the Close ##################")
adf.test(btc_data$Close)

print("################## Testing for the log Returns ##################")
adf.test(btc_data$Bit_log_returns[2:n])

print("################## Testing for the Simple Returns ##################")
adf.test(btc_data$Bit_returns[2:n])

print("################## Testing for the Volume ##################")
adf.test(btc_data$Volume)

print("################## Testing for the Marketcap ##################")
adf.test(btc_data$Marketcap)

print("################## Testing for the Day's Range ##################")
adf.test(btc_data$Bit_days_range)

print("################## Testing for the WTD Returns ##################")
adf.test(btc_data$Bit_log_wtd_ret[8:n])

print("################## Testing for the Bi -WTD Returns ##################")
adf.test(btc_data$Bit_log_biwtd_ret[15:n])

print("################## Testing for the MTD Returns ##################")
adf.test(btc_data$Bit_log_mtd_ret[31:n])

print("################## Testing for the 7 day EMA Daily Returns ##################")
adf.test(btc_data$ema_log_ret_7[8:n])

print("################## Testing for the 14 day EMA Daily Returns ##################")
adf.test(btc_data$ema_log_ret_14[15:n])

print("################## Testing for the 30 day EMA Daily Returns ##################")
adf.test(btc_data$ema_log_ret_30[31:n])

print("################## Testing for 30 day RSI ##################")
adf.test(btc_data$Bit_rsi_3[31:n])

print("################## Testing for 60 day RSI ##################")
adf.test(btc_data$Bit_rsi_60[61:n])

print("################## Testing for 90 day RSI ##################")
adf.test(btc_data$Bit_rsi_90[91:n])

print("################## Testing for 10 day moving average ##################")
adf.test(btc_data$moving_avg_10[11:n])

print("################## Testing for 20 day moving average ##################")
adf.test(btc_data$moving_avg_20[21:n])

print("################## Testing for 50 day moving average ##################")
adf.test(btc_data$moving_avg_50[21:n])

print("################## Testing for the 1 Day Difference between 50 day moving average ##################")
adf.test(btc_data$moving_avg_50_diff[100:n])

print("################## Testing for the 7 Day Difference between 50 day moving average ##################")
adf.test(btc_data$moving_avg_50_diff_7[110:n])

```

From the ADF Test we can see that from the features Closing Price, and Market Cap have unit roots which means that they are not non-stationary. We accounted for the non-stationary features in statistical models for time series data sets by creating features based on calculating the differences between consecutive observations in the data. Now that we have an understanding of what is stationary and non-stationary and we have accounted for non-stationary features, let's partition the data into training and testing out of time samples.

```{r,eval=TRUE,warning=FALSE}

time_cols <- c("Date", "Bit_log_wtd_ret", "Bit_log_biwtd_ret",
               "Bit_log_mtd_ret")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + ggtitle("Log WTD, BI-WTD, and MTD Returns")

time_cols <- c("Date", "ema_log_ret_7", "ema_log_ret_14","ema_log_ret_30")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line2<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + geom_hline(aes(yintercept = 0, colour = "Black")) + ggtitle("EMA 7, 14, and 30 days of Daily Log Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
wtd_dens <-  ggplot(btc_data, aes(x=Bit_log_wtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("WTD Returns")

wtd_qq <- ggplot(btc_data, aes(sample = Bit_log_wtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("WTD Returns")

wtd_box <- ggplot(btc_data, aes(y = Bit_log_wtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("WTD Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
biwtd_dens <-  ggplot(btc_data, aes(x=Bit_log_biwtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("Bi-WTD Returns")

biwtd_qq <- ggplot(btc_data, aes(sample = Bit_log_biwtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("Bi-WTD Returns")

biwtd_box <- ggplot(btc_data, aes(y = Bit_log_biwtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("Bi-WTD Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
mtd_dens <-  ggplot(btc_data, aes(x=Bit_log_mtd_ret)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("MTD Returns")

mtd_qq <- ggplot(btc_data, aes(sample = Bit_log_mtd_ret)) + stat_qq() + stat_qq_line() + ggtitle("MTD Returns")

mtd_box <- ggplot(btc_data, aes(y = Bit_log_mtd_ret)) + geom_boxplot(width = 0.5) + ggtitle("MTD Returns")

# Plot the Moving average difference returns as a density plot, box plot, and qqplot
ma_diff_dens <-  ggplot(btc_data, aes(x=moving_avg_50_diff)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("50 Day MA 1 day differnence")

ma_diff_qq <- ggplot(btc_data, aes(sample = moving_avg_50_diff)) + stat_qq() + stat_qq_line() + ggtitle("50 Day MA 1 day differnence")

ma_diff_box <- ggplot(btc_data, aes(y = moving_avg_50_diff)) + geom_boxplot(width = 0.5) + ggtitle("50 Day MA 1 day differnence")

# Plot the Moving Average as a density plot, box plot, and qqplot
ma7_diff_dens <-  ggplot(btc_data, aes(x=moving_avg_50_diff_7)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("50 Day MA 7 days differnence")

ma7_diff_qq <- ggplot(btc_data, aes(sample = moving_avg_50_diff_7)) + stat_qq() + stat_qq_line() + ggtitle("50 Day MA 7 days differnence")

ma7_diff_box <- ggplot(btc_data, aes(y = moving_avg_50_diff_7)) + geom_boxplot(width = 0.5) + ggtitle("50 Day MA 7 days differnence")

# Create time series chart of the moving averages
time_cols <- c("Date", "moving_avg_50_diff_7", "moving_avg_50_diff")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line_ma<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + ggtitle("Moving Averages difference from Jan 2014 - Jan 2015")

grid.arrange(time_line, time_line2, ncol = 1, nrow = 2)
grid.arrange(wtd_dens, wtd_qq, wtd_box, biwtd_dens, biwtd_qq, biwtd_box, mtd_dens, mtd_qq, mtd_box, ncol = 3, nrow = 3)
grid.arrange(ma_diff_dens, ma_diff_qq, ma_diff_box, ma7_diff_dens, ma7_diff_qq, ma7_diff_box, ncol = 3, nrow = 2)
grid.arrange(time_line_ma, ncol = 1, nrow = 1)

```

Let's create a another EMA set of features, this time using a bi-weekly cadence.

```{r,eval=TRUE,warning=FALSE}

# Additional Features:
# 
# ema_log_biret_7 - the exponential moving average using biweekly returns. The time window for the value is at time t and t-7
# ema_log_biret_14 - the exponential moving average using biweekly returns. The time window for the value is at time t and t-14
# ema_log_biret_30 - the exponential moving average using biweekly returns. The time window for the value is at time t and t-30

#Get the 7 day exponential moving average of daily returns
btc_data$ema_log_biret_7 <- EMA(btc_data$Bit_log_biwtd_ret, 7)

#Get the 14 day exponential moving average of daily returns
btc_data$ema_log_biret_14 <- EMA(btc_data$Bit_log_biwtd_ret, 14)

#Get the 30 day exponential moving average of daily returns
btc_data$ema_log_biret_30 <- EMA(btc_data$Bit_log_biwtd_ret, 30)

time_cols <- c("Date", "ema_log_biret_7", "ema_log_biret_14","ema_log_biret_30")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line3<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + geom_hline(aes(yintercept = 0, colour = "Black")) + ggtitle("EMA 7, 14, and 30 days of BI Weekly to date Log Returns")

time_cols <- c("Date", "Close")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
time_line6<- ggplot(btc_time,
                   aes(x = Date,
                       y = Close,
                       alpha=0.25)) +
              geom_line() + ggtitle("Prices Jan 2014 - Jan 2015")

#plot the 50 day moving average
time_cols <- c("Date", "moving_avg_50")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
time_line50<- ggplot(btc_time,
                   aes(x = Date,
                       y = moving_avg_50,
                       alpha=0.25)) +
              geom_line() + ggtitle("Prices Jan 2014 - Jan 2015")
ma_dens <-  ggplot(btc_data, aes(x=moving_avg_50)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("MTD Returns")
ma_qq <- ggplot(btc_data, aes(sample = moving_avg_50)) + stat_qq() + stat_qq_line() + ggtitle("MTD Returns")
ma_box <- ggplot(btc_data, aes(y = moving_avg_50)) + geom_boxplot(width = 0.5) + ggtitle("MTD Returns")

grid.arrange(time_line2, time_line3, time_line6, time_line50, ncol = 1, nrow = 4)
grid.arrange(ma_dens, ma_qq, ma_box, ncol = 3, nrow = 1)

```
Get the EMA for monthly returns, plot it against the ema for Bi wtd and closing prices of Bitcoin

```{r,eval=TRUE,warning=FALSE}

# Get the 7-day exponential moving average of daily returns
btc_data$ema_log_mtdret_7 <- EMA(btc_data$Bit_log_mtd_ret, 7)

# Get the 14-day exponential moving average of daily returns
btc_data$ema_log_mtdret_14 <- EMA(btc_data$Bit_log_mtd_ret, 14)

# Get the 30-day exponential moving average of daily returns
btc_data$ema_log_mtdret_30 <- EMA(btc_data$Bit_log_mtd_ret, 30)

time_cols <- c("Date", "ema_log_mtdret_7", "ema_log_mtdret_14","ema_log_mtdret_30")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- melt(btc_time, id.vars = "Date")
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

time_line5<- ggplot(btc_time,
                   aes(x = Date,
                       y = value,
                       col = variable,
                       alpha=0.25)) +
              geom_line() + geom_hline(aes(yintercept = 0, colour = "Black")) + ggtitle("EMA 7, 14, and 30 days of MTD Log Returns")

time_cols <- c("Date", "Close")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2014-01-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]

grid.arrange(time_line3, time_line5, time_line6, ncol = 1, nrow = 3)

```

Get the graphs of the EMA values that were recently created.

```{r,eval=TRUE,warning=FALSE}

# Plot the simple returns as a density plot, box plot, and qqplot
ema_mtd_dens <-  ggplot(btc_data, aes(x=ema_log_mtdret_30)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("EMA 30 MTD Returns")
ema_mtd_qq <- ggplot(btc_data, aes(sample = ema_log_mtdret_30)) + stat_qq() + stat_qq_line() + ggtitle("EMA 30 MTD Returns")
ema_mtd_box <- ggplot(btc_data, aes(y = ema_log_mtdret_30)) + geom_boxplot(width = 0.5) + ggtitle("EMA 30 MTD Returns")

# Plot the simple returns as a density plot, box plot, and qqplot
ema_biwtd_dens <-  ggplot(btc_data, aes(x=ema_log_biret_30)) +
              geom_histogram(aes(y = ..density..), bins= 20, colour = 1, fill= "blue", alpha = 0.6) +
              geom_density() + ggtitle("EMA BI-WTD Returns")
ema_biwtd_qq <- ggplot(btc_data, aes(sample = ema_log_biret_30)) + stat_qq() + stat_qq_line() + ggtitle("EMA 30 BI-WTD Returns")
ema_biwtd_box <- ggplot(btc_data, aes(y = ema_log_biret_30)) + geom_boxplot(width = 0.5) + ggtitle("EMA 30 BI-WTD Returns")

grid.arrange(ema_mtd_dens, ema_mtd_qq, ema_mtd_box, ema_biwtd_dens, ema_biwtd_qq, ema_biwtd_box, ncol = 3, nrow = 2)

```

Shift the week to date, bi week to date, and month to date up the number of units it used to calclute the metric. (i.e week date used t and t-7 to calculate. Shift the rows up replacing the previous null values). This will now give the future returns at time t.

```{r,eval=TRUE,warning=FALSE}

# Shift the columns back n days so current features align with the labeled future values
n <- nrow(btc_data) 
btc_data$Bit_log_wtd_ret_lag <- c(btc_data$Bit_log_wtd_ret[8:n], rep(NA,7))
btc_data$Bit_log_biwtd_ret_lag <- c(btc_data$Bit_log_biwtd_ret[15:n], rep(NA,14))
btc_data$Bit_log_mtd_ret_lag <- c(btc_data$Bit_log_mtd_ret[31:n], rep(NA,30))

# Create the indicators on when to buy when to sell and when to hold
btc_data$buy_sell_ind_wtd <- ifelse(btc_data$Bit_log_wtd_ret_lag >=  0.2, 1, ifelse(btc_data$Bit_log_wtd_ret_lag <=  -0.15, -1, 0))
btc_data$buy_sell_ind_biwtd <- ifelse(btc_data$Bit_log_biwtd_ret_lag >=  0.2, 1, ifelse(btc_data$Bit_log_biwtd_ret_lag <=  -0.15, -1, 0))
btc_data$buy_sell_ind_mtd <- ifelse(btc_data$Bit_log_mtd_ret_lag >=  0.2, 1, ifelse(btc_data$Bit_log_mtd_ret_lag <=  -0.15, -1, 0))

# Make the new columns as factor type
btc_data$buy_sell_ind_wtd <- as.factor(btc_data$buy_sell_ind_wtd)
btc_data$buy_sell_ind_biwtd <- as.factor(btc_data$buy_sell_ind_biwtd)
btc_data$buy_sell_ind_mtd <- as.factor(btc_data$buy_sell_ind_mtd)

# Remove the rows with null values at the beginning and end of the data frame.
btc <- btc_data[complete.cases(btc_data),]

# Partition the data into training and testing sets.
train_indx <- round(0.7 * nrow(btc))
btc_train <- btc[1:train_indx,]
test_indx <- train_indx + 1
n_btc <- nrow(btc)
btc_test <- btc[test_indx:n_btc,]

```

Look at the relationships between EMA Values and their expected future returns

```{r,eval=TRUE,warning=FALSE}

day <- ggplot(btc_train, aes(x=Bit_log_mtd_ret, y=Bit_log_wtd_ret_lag, color=buy_sell_ind_wtd)) + 
        geom_point(alpha=0.5, shape=18) + geom_vline(aes(xintercept = 0)) + geom_hline(aes(yintercept = 0))

week <- ggplot(btc_train, aes(x=ema_log_biret_30, y=Bit_log_wtd_ret_lag, color=buy_sell_ind_wtd)) + 
        geom_point(alpha=0.5, shape=18) + geom_vline(aes(xintercept = 0)) + geom_hline(aes(yintercept = 0))

month <- ggplot(btc_train, aes(x=Bit_log_biwtd_ret_lag, y=Bit_log_mtd_ret_lag, color=buy_sell_ind_mtd)) + 
        geom_point(alpha=0.5, shape=18) + geom_vline(aes(xintercept = 0)) + geom_hline(aes(yintercept = 0))

grid.arrange(day, week, month, ncol = 1, nrow = 3)

names(btc_train)
cor_feat <- cor(btc_train[, 5:34])
corrplot(cor_feat, method="color", addCoef.col = 0.5, number.cex = 0.5, tl.cex = 0.5)

```

plot the buy and sell points on a chart of prices.

```{r,eval=TRUE,warning=FALSE}

time_cols <- c("Date", "Close", "buy_sell_ind_mtd")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2013-06-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
btc_points <- btc_time[btc_time$buy_sell_ind_mtd == -1, ]
plot(x = btc_time$Date,
    y = btc_time$Close, main = "Sell Indicators between Jun 2013 - Jan 2015")
points(x = btc_points$Date, y=btc_points$Close, col="red")

time_cols <- c("Date", "Close", "buy_sell_ind_mtd")
btc_time <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_time <- btc_time[btc_time$Date > "2013-06-01" &    # Extract data frame subset
                   btc_time$Date < "2015-01-01", ]
btc_points <- btc_time[btc_time$buy_sell_ind_mtd == 1, ]
plot(x = btc_time$Date,
    y = btc_time$Close, main = "Buy Indicators between Jun 2013 - Jan 2015")
points(x = btc_points$Date, y=btc_points$Close, col="green")

```

After some research we will use the xgboost algorithm to classify when to buy and when to sell based where we think positive returns will be a month out from the point in time.

XGBoost can be used for either regression or classification problems. In our case we engineered our target variable with 0s and 1s, making it a classification problem. We will see if using xgboost as classification model would be able to spot good buy moments in the data.

Xgboost in time series: https://machinelearningmastery.com/xgboost-for-time-series-forecasting/

Why model using log returns: https://medium.datadriveninvestor.com/why-we-use-log-returns-for-stock-returns-820cec4510ba

# Main

```{r,eval=TRUE,warning=FALSE}

str(btc_train)
rm_cols <- c("SNo", "Name", "Symbol", "High", "Low", "Open", "Close", "Marketcap", "buy_sell_ind_wtd", "buy_sell_ind_biwtd",
             "Bit_log_wtd_ret_lag", "Bit_log_biwtd_ret_lag", "Bit_log_mtd_ret_lag", "buy_sell_ind_mtd", "moving_avg_10",
             "moving_avg_20")

# Predict on when is a good time to buy
btc_train$buy_indicator <- ifelse(btc_train$buy_sell_ind_mtd == 1, 1, 0)
btc_test$buy_indicator <- ifelse(btc_test$buy_sell_ind_mtd == 1, 1, 0)
btc_train <- btc_train[, !(colnames(btc_train) %in% rm_cols)]
btc_test <- btc_test[, !(colnames(btc_test) %in% rm_cols)]

# Convert the date into integers of month day and year, each with its own column to preserve the temporal aspect of the data
btc_train <- btc_train %>%
    dplyr::mutate(., 
                  months = lubridate::month(Date),
                  years = lubridate::year(Date),
                  days = lubridate::day(Date))

btc_test <- btc_test %>%
    dplyr::mutate(., 
                  months = lubridate::month(Date),
                  years = lubridate::year(Date),
                  days = lubridate::day(Date))

# Convert the days column to numeric
btc_test$days <- as.numeric(btc_test$days)
btc_train$days <- as.numeric(btc_train$days)
btc_test$months <- as.numeric(btc_test$months)
btc_train$months <- as.numeric(btc_train$months)
btc_test$year <- as.numeric(btc_test$years)
btc_train$years <- as.numeric(btc_train$years)

# Create the matrix values for the xgboost
x_train <- btc_train %>%
                    dplyr::select(months, days, years, Volume, Bit_log_returns, Bit_returns, Bit_days_range, Bit_log_wtd_ret, Bit_log_biwtd_ret,
                    Bit_log_mtd_ret, ema_log_ret_7, ema_log_ret_14, ema_log_ret_30, Bit_rsi_3, Bit_rsi_60, Bit_rsi_90,
                    ema_log_biret_7, ema_log_biret_14, ema_log_biret_30, ema_log_mtdret_7, ema_log_mtdret_14, ema_log_mtdret_30, moving_avg_50,
                    moving_avg_50_diff, moving_avg_50_diff_7) %>%
                  as.matrix()

x_test <- btc_test %>% 
                  dplyr::select(months, days, years, Volume, Bit_log_returns, Bit_returns, Bit_days_range, Bit_log_wtd_ret, Bit_log_biwtd_ret,
                  Bit_log_mtd_ret, ema_log_ret_7, ema_log_ret_14, ema_log_ret_30, Bit_rsi_3, Bit_rsi_60, Bit_rsi_90,
                  ema_log_biret_7, ema_log_biret_14, ema_log_biret_30, ema_log_mtdret_7, ema_log_mtdret_14, ema_log_mtdret_30, moving_avg_50,
                  moving_avg_50_diff, moving_avg_50_diff_7) %>%
                as.matrix()
y_train <- as.factor(btc_train$buy_indicator)
y_test <- as.factor(btc_test$buy_indicator)

```

link:
https://www.r-bloggers.com/2019/09/time-series-forecasting-with-random-forest/

```{r,eval=TRUE,warning=FALSE}

#nrow(btc_train)
set.seed(123)
xgb_trcontrol <- caret::trainControl(
   method = "timeslice",
   initialWindow = 200,
   horizon = 70,
   fixedWindow = FALSE, 
   allowParallel = FALSE
)

```

```{r,eval=TRUE,warning=FALSE}
xgb_grid <- base::expand.grid(
   list(
    nrounds = c(150, 250),
    max_depth = c(20, 50, 100), # maximum depth of a tree
    colsample_bytree = seq(0.5), # subsample ratio of columns when construction each tree
    eta = 0.1, # learning rate
    gamma = 0, # minimum loss reduction
    min_child_weight = 1,  # minimum sum of instance weight (hessian) needed ina child
    subsample = 1 # subsample ratio of the training instances
))

```

```{r,eval=TRUE,warning=FALSE}

cl <- makePSOCKcluster(5)
registerDoParallel(cl)

xgb_model <- caret::train(
   x_train, y_train,
   trControl = xgb_trcontrol,
   tuneGrid = xgb_grid,
   method = "xgbTree",
   nthread = 1,
   objective = "binary:logistic",
   verbosity = 0
)

stopCluster(cl)

```

```{r,eval=TRUE,warning=FALSE}
xgb_model$bestTune

importance_matrix <- xgb.importance(model = xgb_model$finalModel)
print(importance_matrix)
xgb.plot.importance(importance_matrix = importance_matrix)

```

As we can see from the feature

## Methodology
```{r,eval=TRUE,warning=FALSE}

train_predicted <- xgb_model %>% predict(x_train)
print("The accuracy score for the buy indicator is below:")
Accuracy(train_predicted, btc_train$buy_indicator)

#Confusion matrix
confMat1 <- ConfusionMatrix(train_predicted, btc_train$buy_indicator)
confMat1

```

With results like that our model could be over fitted.

```{r,eval=TRUE,warning=FALSE}

test_predicted <- xgb_model %>% predict(x_test)
print("The accuracy score for the buy indicator is below:")
Accuracy(test_predicted, btc_test$buy_indicator)

# Confusion matrix
confMat2 <- ConfusionMatrix(test_predicted, btc_test$buy_indicator)
confMat2

roc_offer <- roc(test_predicted, as.integer(btc_test$buy_indicator))
plot(roc_offer)

btc_test$pred1 <- test_predicted

time_cols <- c("Date", "Close")
btc_sub <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_test <- left_join(btc_test, btc_sub, by="Date")
time_cols <- c("Date", "Close", "pred1")
btc_time <- btc_test[, (colnames(btc_test) %in% time_cols)]
btc_points <- btc_time[btc_time$pred1 == 1, ]
plot(x = btc_time$Date,
    y = btc_time$Close, main = "Buy Indicators between Jun 2013 - Jan 2015")
points(x = btc_points$Date, y=btc_points$Close, col="green")

```

As we can see our model did perfectly well at segmenting the data perfectly. However, it did poorly against the testing data. The columns that we care about most is the ratio between true positive false positives from a business standpoint. Reason being is that, those 2 counts indicate a buy order was made. From a business standpoint we would want to first ensure that a buy indicator indicates a winning buy order, being that the returns will be positive.

This time lets train the model stripping some of the lesser important features, which should slim our data down. Then we will increase the window size of the testing in the cross validation step.

```{r,eval=TRUE,warning=FALSE}

# create the matrix values for the xgboost
x_train_2 <- btc_train %>%
                    dplyr::select(months, days, years,
                    Bit_log_mtd_ret, ema_log_ret_14, Bit_rsi_90,
                    ema_log_mtdret_30, moving_avg_50_diff_7) %>%
                  as.matrix()

x_test_2 <- btc_test %>%
                  dplyr::select(months, days, years,
                    Bit_log_mtd_ret, ema_log_ret_14, Bit_rsi_90,
                    ema_log_mtdret_30, moving_avg_50_diff_7) %>%
                as.matrix()

set.seed(123)
xgb_trcontrol_2 <- caret::trainControl(
   method = "timeslice",
   initialWindow = 700,
   horizon = 200,
   fixedWindow = FALSE,
   allowParallel = FALSE
   )

xgb_grid_2 <- base::expand.grid(
   list(
    nrounds = c(100, 200),
    max_depth = c(10, 15, 20), # maximum depth of a tree
    colsample_bytree = seq(0.5), # sub-sample ratio of columns when construction each tree
    eta = 0.1, # learning rate
    gamma = 0, # minimum loss reduction
    min_child_weight = 1,  # minimum sum of instance weight (hessian) needed ina child
    subsample = 1 # sub-sample ratio of the training instances
    )
)

```

```{r,eval=TRUE,warning=FALSE}

cl <- makePSOCKcluster(5)
registerDoParallel(cl)

xgb_model_2 <- suppressMessages(caret::train(
   x_train, y_train,
   trControl = xgb_trcontrol_2,
   tuneGrid = xgb_grid_2,
   method = "xgbTree",
   nthread = 1,
   objective = "binary:logistic",
   verbosity = 0
))

stopCluster(cl)

```

Although we have an accuracy of 100% on the training data, the accuracy dropped down to 66% on the test data which points to the possibility of over-fitting. Additionally, although the accuracy of 100% was higher than the 79% base line rate on the training data. This failed to translate over when the model was applied on the test data with the accuracy of 66% being below the base line rate of 67%. Sadly these results do not point to an effective model and more analysis will be required.

The ROC curves also indicate possible over-fitting with the curve on the training data almost touching the upper left corner with an AUC of 100% while the curve on the test data is closer to the diagonal of the graph with an AUC of 51.9%:

```{r,eval=TRUE,warning=FALSE}

train_predicted_2 <- xgb_model_2 %>% predict(x_train)
print("The accuracy score for the buy indicator is bellow:")
Accuracy(train_predicted_2, btc_train$buy_indicator)

# Confusion matrix
confMat1_2 <- ConfusionMatrix(train_predicted_2, btc_train$buy_indicator)
confMat1_2

test_predicted_2 <- xgb_model_2 %>% predict(x_test)
print("The accuracy score for the buy indicator is bellow:")
Accuracy(test_predicted_2, btc_test$buy_indicator)

# Confusion matrix
confMat2_2 <- ConfusionMatrix(test_predicted_2, btc_test$buy_indicator)
confMat2_2

```

Check the kind of trade that the algorithm predicted.

```{r,eval=TRUE,warning=FALSE}

time_cols <- c("Date", "Close")
btc_sub <- btc_data[, (colnames(btc_data) %in% time_cols)]
btc_test <- left_join(btc_test, btc_sub, by="Date")
btc_test$pred_1 <- test_predicted_2
time_cols <- c("Date", "Close", "pred_1")
btc_time <- btc_test[, (colnames(btc_test) %in% time_cols)]
btc_points <- btc_time[btc_time$pred_1 == 1, ]
plot(x = btc_time$Date,
    y = btc_time$Close, main = "Buy Indicators between Jun 2013 - Jan 2015")
points(x = btc_points$Date, y=btc_points$Close, col="green")

max(btc_test$Date)

```

#### Assumptions

The Covid-19 pandemic was a global event that greatly impacted the cryptocurrency market. The data used for this study undoubtedly shows the impact of this event; however, our assumption in using historical data to make predictions is that similar patterns in history are likely to reoccur in the future. Our assumption in using this data is that the underlying patterns, whether or not they have been impacted by the pandemic, will still be predictive.

Additionally, since logistic regression is used for this analysis, we assume that there is a linear relationship between the predictors and the response variables and that errors are independent normal random variables with mean zero and constant variance.

#### Results and Conclusions
Below is our final model for this analysis:

This model shows that the below indicator using the 50-day moving average is significant at the 95% confidence-level for the “0” level with an AIC of 398.64.

The sustained below indicator variable for the 50-day moving average also proved to be significant at the 95% confidence-level for the “0” level; however it has a higher p-value and marginally higher AIC of 398.99. This was therefore not selected to be our final model.

# Challenges and Limitations

# Further Discussion and Research

Cryptocurrency asset class research is a rapidly evolving space, and our research is is just beginning to scratch the surface. There are several other interesting areas to look into to evolve research findings so that insights can provide a better view into answering these questions:

1. Would other moving averages besides the 10, 20, and 50 day averages be more effective?
2. Will other options for the sustained below indicator be more predictive than 5 days?
3. Can this analysis be modified to look at hourly or minute by minute data as opposed to daily?
4. Would our analysis roughly stay true by increasing the data set time range?
5. Would our analysis roughly stay true with other mainstream cryptocurrencies?
6. Are there significant and consistent correlations between mainstream cryptocurrency features, including Bitcoin?
7. What is the impact of taxes on market size and trading volume in the future?
8. What was the impact of the pandemic and other global macro economic forces such as public debt and unemployment rates, on cryptocurrency features?

# References
